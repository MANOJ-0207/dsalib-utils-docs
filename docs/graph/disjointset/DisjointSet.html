<!DOCTYPE html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DisjointSet - Docs</title>
    <link rel="stylesheet" href="../../../styles/docs.css" />
    <link
      rel="icon"
      type="image/x-icon"
      href="../../assets/dependency-favicon.png"
    />
  </head>
  <body>
    <!-- Theme Toggle Button -->
    <div
      class="theme-toggle"
      onclick="toggleTheme()"
      title="Toggle Theme"
      id="theme-toggle"
    >
      <img id="icon-sun" src="../../../assets/sun.png" />
      <img id="icon-moon" src="../../../assets/moon.png" />
    </div>

    <div class="doc-container">
      <!-- Header -->
      <header>
        <h1>DisjointSet</h1>
        <p class="class-type">
          Type: <span class="tag class-tag">Concrete Class</span>
        </p>
      </header>

      <!-- Description -->
      <section class="doc-section">
        <h2>Description</h2>
        <p>
          <code>DisjointSet&lt;K&gt;</code> is a generic implementation of the
          Union-Find data structure, supporting efficient union and find
          operations using <strong>union by rank</strong> and
          <strong>path compression</strong>. These heuristics make operations
          nearly constant time, which is especially useful in connectivity,
          clustering, and MST algorithms.
        </p>
      </section>

      <!-- Use Cases -->
      <section class="doc-section">
        <h2>Use Cases</h2>
        <ul>
          <li>Finding connected components in a graph</li>
          <li>Kruskal's algorithm for Minimum Spanning Tree</li>
          <li>Clustering data with dynamic merges</li>
          <li>Cycle detection in undirected graphs</li>
        </ul>
      </section>

      <!-- Method Summary -->
      <section class="doc-section">
        <h2>Method Summary</h2>
        <table class="doc-table">
          <thead>
            <tr>
              <th>Return Type</th>
              <th>Method</th>
              <th>Description</th>
              <th>Time Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>void</code></td>
              <td><code>makeSet(K x)</code></td>
              <td>Creates a singleton set with the given element.</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td><code>K</code></td>
              <td><code>find(K x)</code></td>
              <td>
                Finds the root representative of the set containing
                <code>x</code>.<br />
                Uses path compression to flatten the structure for future
                efficiency.
              </td>
              <td>
                O(α(n))<br /><small
                  >(α is the inverse Ackermann function, practically &lt;
                  5)</small
                >
              </td>
            </tr>
            <tr>
              <td><code>boolean</code></td>
              <td><code>union(K x, K y)</code></td>
              <td>
                Merges the sets containing <code>x</code> and
                <code>y</code>.<br />
                Returns <code>true</code> only if they were in different
                sets.<br />
                Uses union by rank to keep tree depth small.
              </td>
              <td>O(α(n))</td>
            </tr>
            <tr>
              <td><code>boolean</code></td>
              <td><code>isConnected(K x, K y)</code></td>
              <td>
                Returns <code>true</code> if <code>x</code> and
                <code>y</code> share the same root.
              </td>
              <td>O(α(n))</td>
            </tr>
            <tr>
              <td><code>Map&lt;K, K&gt;</code></td>
              <td><code>getParentMap()</code></td>
              <td>
                Returns a shallow copy of the internal <code>parent</code> map
                for debugging or inspection.
              </td>
              <td>O(n)</td>
            </tr>
          </tbody>
        </table>
      </section>

      <section class="doc-section">
        <h2>Implementation Details</h2>
        <p>
          <code>DisjointSet&lt;K&gt;</code> is a generic implementation of the
          <strong>Union-Find (Disjoint Set Union)</strong> data structure
          optimized for near-constant-time operations using
          <strong>path compression</strong> and <strong>union by rank</strong>.
          It is designed for dynamic creation and merging of disjoint sets
          during runtime.
        </p>

        <p><strong>Core Data Structures:</strong></p>
        <ul>
          <li>
            <strong>Parent Map</strong> –
            <code>Map&lt;K, K&gt; parent</code> maps each element to its
            representative (root). Initialized lazily when elements are first
            used.
          </li>
          <li>
            <strong>Rank Map</strong> –
            <code>Map&lt;K, Integer&gt; rank</code> stores the tree height
            approximation used during unions.
          </li>
        </ul>

        <p><strong>Initialization Behavior:</strong></p>
        <ul>
          <li>
            <strong>Lazy Set Creation</strong> – Elements are automatically
            initialized upon first <code>find</code> or <code>union</code> if
            not explicitly added via <code>makeSet()</code>.
          </li>
          <li>
            <strong>Optional Batch Init</strong> – Constructor accepts an
            <code>Iterable&lt;K&gt;</code>
            to prepopulate disjoint elements in bulk.
          </li>
        </ul>

        <p><strong>Union Optimization:</strong></p>
        <ul>
          <li>
            <strong>Union by Rank</strong> – Always attaches the smaller
            (shallower) tree to the deeper one to minimize height growth.
          </li>
          <li>
            <strong>Rank Updates</strong> – Rank is incremented only when both
            sets are of equal height.
          </li>
        </ul>

        <p><strong>Find Optimization:</strong></p>
        <ul>
          <li>
            <strong>Path Compression</strong> – Collapses tree paths during
            <code>find()</code>, so all visited nodes point directly to the
            root.
          </li>
          <li>
            <strong>Amortized Cost</strong> – Both <code>find</code> and
            <code>union</code> operations run in O(α(n)), where α is the inverse
            Ackermann function (effectively constant).
          </li>
        </ul>

        <p><strong>Utility and Debugging:</strong></p>
        <ul>
          <li>
            <strong>Connectivity Checks</strong> –
            <code>isConnected(x, y)</code> compares roots of two elements.
          </li>
          <li>
            <strong>Debug Support</strong> –
            <code>getParentMap()</code> provides a shallow copy of the internal
            parent relationships for inspection or visualization.
          </li>
        </ul>
      </section>

      <!-- Detailed Examples -->
      <section class="doc-section">
        <h2>Detailed Usage Examples</h2>

        <h3><code>makeSet(K x)</code></h3>
        <p>Initializes a new disjoint set element if not already present.</p>
        <pre class="code-block"><code>
DisjointSet&lt;String&gt; ds = new DisjointSet&lt;&gt;();
ds.makeSet("X");  // Creates set {X}
        </code></pre>

        <h3><code>find(K x)</code></h3>
        <p>
          Returns the root representative of <code>x</code>. If
          <code>x</code> does not exist, it is lazily initialized (i.e.,
          auto-<code>makeSet(x)</code>).
        </p>
        <pre class="code-block"><code>
String root = ds.find("X");  // Returns "X"
        </code></pre>

        <h3><code>union(K x, K y)</code></h3>
        <p>
          Connects the sets of <code>x</code> and <code>y</code>. Returns
          <code>false</code> if they are already connected, preventing
          unnecessary merges.
        </p>
        <pre class="code-block"><code>
ds.union("X", "Y");  // Now X and Y are in the same set
ds.union("Y", "Z");  // Also connects Z to the same component
        </code></pre>

        <h3><code>isConnected(K x, K y)</code></h3>
        <p>Checks whether two elements belong to the same component.</p>
        <pre class="code-block"><code>
boolean result = ds.isConnected("X", "Z");  // true
        </code></pre>

        <h3><code>getParentMap()</code></h3>
        <p>
          Useful for debugging the internal state of the disjoint set. Note:
          Returns a copy, so modifying the result won't affect internal state.
        </p>
        <pre class="code-block"><code>
Map&lt;String, String&gt; snapshot = ds.getParentMap();
System.out.println(snapshot); // {X=Y, Y=Z, Z=Z}
        </code></pre>
      </section>

      <!-- Implementation Notes -->
      <section class="doc-section">
        <h2>Implementation Notes</h2>
        <ul>
          <li>
            <strong>Path compression</strong> ensures <code>find</code> flattens
            the tree structure.
          </li>
          <li>
            <strong>Union by rank</strong> minimizes tree height by always
            attaching the shorter tree under the taller one.
          </li>
          <li>
            α(n) refers to the inverse Ackermann function, which is nearly
            constant for all practical input sizes.
          </li>
          <li>
            Calling <code>find(x)</code> for an unknown <code>x</code> will
            automatically call <code>makeSet(x)</code>.
          </li>
        </ul>
      </section>

      <!-- Sample Usage -->
      <section class="doc-section">
        <h2>Quick Example</h2>
        <pre class="code-block"><code>
DisjointSet&lt;Integer&gt; ds = new DisjointSet&lt;&gt;();
ds.union(1, 2);
ds.union(3, 4);
ds.union(2, 4);
System.out.println(ds.find(1)); // Same as find(4)
System.out.println(ds.isConnected(1, 3)); // true
        </code></pre>
      </section>
    </div>
    <footer>© 2025 Java Generic DSA Utils | Manoj Kumar G</footer>
    <script src="../../../scripts/docs.js"></script>
  </body>
</html>
