<!DOCTYPE html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AdjListSimpleGraph - Docs</title>
    <link rel="stylesheet" href="../../../styles/docs.css" />
    <link
      rel="icon"
      type="image/x-icon"
      href="../../assets/dependency-favicon.png"
    />
  </head>
  <body>
    <div
      class="theme-toggle"
      onclick="toggleTheme()"
      title="Toggle Theme"
      id="theme-toggle"
    >
      <img id="icon-sun" src="../../../assets/sun.png" />
      <img id="icon-moon" src="../../../assets/moon.png" />
    </div>

    <div class="doc-container">
      <header>
        <h1>AdjListSimpleGraph</h1>
        <p class="class-type">
          Type: <span class="tag class-tag">Concrete Class</span>
        </p>
      </header>

      <section class="doc-section">
        <h2>Description</h2>
        <p>
          <code>AdjListSimpleGraph&lt;K&gt;</code> which implements <a href="SimpleGraph.html" target="_blank" class="doc-link"
            >SimpleGraph</a
          > interface is a generic graph
          implementation using an adjacency list. It supports both
          <strong>directed</strong> and <strong>undirected</strong> graphs and
          includes features like BFS, DFS, topological sorting, shortest paths,
          and bridge/articulation point detection via
          <strong>Tarjan’s algorithm</strong>.
        </p>
      </section>

      <section class="doc-section">
        <h2>Use Cases</h2>
        <ul>
          <li>Generic graph structure with fast mutation and traversal</li>
          <li>Efficient BFS/DFS traversals</li>
          <li>Topological sorting (only in directed mode)</li>
          <li>Finding articulation points and bridge edges</li>
        </ul>
      </section>

      <section class="doc-section">
        <h2>Method Summary</h2>
        <table class="doc-table">
          <thead>
            <tr>
              <th>Return Type</th>
              <th>Method</th>
              <th>Description</th>
              <th>Time</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>N/A</code></td>
              <td><code>AdjListSimpleGraph()</code></td>
              <td>Constructs a undirected adjacency list graph</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td><code>N/A</code></td>
              <td><code>AdjListSimpleGraph(boolean isDirected)</code></td>
              <td>
                Constructs a adjacency list graph directed/undirected based on
                isDirected flag
              </td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>void</td>
              <td><code>addEdge(K from, K to)</code></td>
              <td>Adds an edge between nodes.</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>void</td>
              <td><code>removeEdge(K from, K to)</code></td>
              <td>Removes the edge between nodes.</td>
              <td>O(deg(from)+deg(to))</td>
            </tr>
            <tr>
              <td>void</td>
              <td><code>bfs(K source, Consumer&lt;K&gt; action)</code></td>
              <td>Breadth-first traversal.</td>
              <td>O(V+E)</td>
            </tr>
            <tr>
              <td>void</td>
              <td><code>dfs(K source, Consumer&lt;K&gt; action)</code></td>
              <td>Depth-first traversal.</td>
              <td>O(V+E)</td>
            </tr>
            <tr>
              <td>List&lt;K&gt;</td>
              <td><code>getTopologicalSort()</code></td>
              <td>Topological order (directed only).</td>
              <td>O(V+E)</td>
            </tr>
            <tr>
              <td>Map&lt;K, Integer&gt;</td>
              <td><code>shortestDistances(K source)</code></td>
              <td>Shortest path from source.</td>
              <td>O(V+E)</td>
            </tr>
            <tr>
              <td>boolean</td>
              <td><code>isReachable(K from, K to)</code></td>
              <td>
                Checks if <code>to</code> is reachable from <code>from</code>.
              </td>
              <td>O(V+E)</td>
            </tr>
            <tr>
              <td>boolean</td>
              <td><code>isConnected()</code></td>
              <td>Checks if the entire graph is connected (undirected).</td>
              <td>O(V+E)</td>
            </tr>
            <tr>
              <td>boolean</td>
              <td><code>isBridgeEdge(K u, K v)</code></td>
              <td>Returns true if the edge is a bridge.</td>
              <td>O(V+E)</td>
            </tr>
            <tr>
              <td>boolean</td>
              <td><code>isBridgeNode(K node)</code></td>
              <td>Returns true if node is an articulation point.</td>
              <td>O(V+E)</td>
            </tr>
            <tr>
              <td>Set&lt;Edge&lt;K&gt;&gt;</td>
              <td><code>getBridgeEdges()</code></td>
              <td>Returns all bridge edges.</td>
              <td>O(V+E)</td>
            </tr>
            <tr>
              <td>Set&lt;K&gt;</td>
              <td><code>getBridgeNodes()</code></td>
              <td>Returns articulation points.</td>
              <td>O(V+E)</td>
            </tr>
            <tr>
              <td>Map&lt;K, List&lt;K&gt;&gt;</td>
              <td><code>getAdjacencyList()</code></td>
              <td>Read-only view of the graph.</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>void</td>
              <td><code>printGraph()</code></td>
              <td>Prints the graph to console.</td>
              <td>O(V+E)</td>
            </tr>
          </tbody>
        </table>
      </section>

      <section class="doc-section">
        <h2>Algorithm Details</h2>
        <p>
          <code>AdjListSimpleGraph&lt;K&gt;</code> is a generic adjacency
          list–based graph supporting both <strong>directed</strong> and
          <strong>undirected</strong> edges. It includes standard graph
          operations and advanced bridge detection using
          <strong>Tarjan's algorithm</strong>.
        </p>

        <p><strong>Tarjan's Algorithm:</strong></p>
        <ul>
          <li>
            Computes <code>low</code> and <code>tin</code> values for bridge
            detection
          </li>
          <li>
            Automatically cached and recalculated when the graph is modified
          </li>
          <li>
            Works on both directed and undirected graphs (uses undirected logic
            for bridges)
          </li>
        </ul>

        <p><strong>Use Cases:</strong></p>
        <ul>
          <li>Graph traversal and exploration</li>
          <li>Topological sorting of DAGs</li>
          <li>Cut edge and cut vertex detection in connectivity analysis</li>
          <li>Reachability and BFS-based shortest path computations</li>
        </ul>
      </section>

      <section class="doc-section">
        <h2>Detailed Usage Examples</h2>
        <pre class="code-block"><code>
AdjListSimpleGraph&lt;Integer&gt; g = new AdjListSimpleGraph&lt;&gt;(); // Undirected
g.addEdge(1, 2);
g.addEdge(2, 3);
g.addEdge(3, 1);
g.addEdge(3, 4);

g.bfs(1, node -&gt; System.out.println("Visited BFS: " + node)); 
// Visited BFS: 1, 2, 3, 4 (order may vary depending on insertion)

g.dfs(1, node -&gt; System.out.println("Visited DFS: " + node)); 
// Visited DFS: 1, 2, 3, 4 (depth-first order)

System.out.println("Shortest distances from 1: " + g.shortestDistances(1)); 
// {1=0, 2=1, 3=1, 4=2}

System.out.println("Is reachable from 1 to 4? " + g.isReachable(1, 4)); 
// true

System.out.println("Is connected? " + g.isConnected()); 
// true

System.out.println("Is edge (3,4) a bridge? " + g.isBridgeEdge(3, 4)); 
// true (removing it increases components)

System.out.println("Bridge nodes: " + g.getBridgeNodes()); 
// [3] (node 3 disconnects node 4)

g.printGraph(); 
// 1 → [2, 3]
// 2 → [1, 3]
// 3 → [2, 1, 4]
// 4 → [3]
  </code></pre>

        <h3>Topological Sort</h3>
        <pre class="code-block"><code>
AdjListSimpleGraph&lt;String&gt; dg = new AdjListSimpleGraph&lt;&gt;(true); // Directed
dg.addEdge("A", "B");
dg.addEdge("B", "C");
System.out.println("Topological order: " + dg.getTopologicalSort()); 
// [A, B, C]
  </code></pre>
      </section>

      <section class="doc-section">
        <h2>Implementation Notes</h2>
        <ul>
          <li>
            Supports <strong>directed</strong> and
            <strong>undirected</strong> graphs (constructor controlled).
          </li>
          <li>
            Bridge edge/node detection uses <strong>Tarjan’s algorithm</strong>.
          </li>
          <li>
            Bridge/articulation results are
            <strong>cached and invalidated</strong> on modification.
          </li>
          <li>
            Directionality is respected in edge creation (see
            <code>Edge&lt;K&gt;</code> usage).
          </li>
        </ul>
      </section>

      <section class="doc-section">
        <h2>Quick Example</h2>
        <pre class="code-block"><code>
AdjListSimpleGraph&lt;Integer&gt; g = new AdjListSimpleGraph&lt;&gt;();
g.addEdge(1, 2);
g.addEdge(2, 3);
g.addEdge(3, 4);

System.out.println(g.isConnected()); 
// true

System.out.println(g.getBridgeEdges()); 
// [(2,3), (3,4)] (undirected)
  </code></pre>
      </section>
    </div>
    <footer>© 2025 Java Generic DSA Utils | Manoj Kumar G</footer>
    <script src="../../../scripts/docs.js"></script>
  </body>
</html>
