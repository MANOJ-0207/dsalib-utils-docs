<!DOCTYPE html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GenericLazySegmentTree - Docs</title>
    <link rel="stylesheet" href="../../../styles/docs.css" />
    <link
      rel="icon"
      type="image/x-icon"
      href="../../assets/dependency-favicon.png"
    />
  </head>
  <body>
    <!-- Theme Toggle Button -->
    <div
      class="theme-toggle"
      onclick="toggleTheme()"
      title="Toggle Theme"
      id="theme-toggle"
    >
      <img id="icon-sun" src="../../../assets/sun.png" />
      <img id="icon-moon" src="../../../assets/moon.png" />
    </div>

    <div class="doc-container">
      <!-- Header -->
      <header>
        <h1>GenericLazySegmentTree</h1>
        <p class="class-type">
          Type: <span class="tag class-tag">Concrete Class</span>
        </p>
      </header>

      <!-- Description -->
      <section class="doc-section">
        <h2>Description</h2>
        <p>
          <code>GenericLazySegmentTree&lt;T&gt;</code> which implements
          <a href="SegmentTree.html" target="_blank" class="doc-link"
            >SegmentTree</a
          >
          is a flexible, generic segment tree implementation that supports
          <strong>lazy propagation</strong> for efficient range updates and
          queries. It is ideal for applications involving frequent interval
          modifications and queries, such as range increments, affine
          transformations, and prefix/suffix aggregation.
        </p>
      </section>

      <!-- Use Cases -->
      <section class="doc-section">
        <h2>Use Cases</h2>
        <ul>
          <li>
            Efficient range updates (e.g., add 1 to all elements in a range)
          </li>
          <li>Minimum/maximum/range sum queries with transformation</li>
          <li>Affine updates, scaling, or conditional replacements</li>
          <li>Heavy segment tree problems in competitive programming</li>
        </ul>
      </section>

      <!-- Method Summary -->
      <section class="doc-section">
        <h2>Method Summary</h2>
        <table class="doc-table">
          <thead>
            <tr>
              <th>Return Type</th>
              <th>Method</th>
              <th>Description</th>
              <th>Time Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>T</code></td>
              <td><code>query(int l, int r)</code></td>
              <td>Returns the aggregated result over the range [l, r].</td>
              <td>O(log n)</td>
            </tr>
            <tr>
              <td><code>void</code></td>
              <td><code>update(int index, T value)</code></td>
              <td>
                Updates a single element directly by replacing it with a new
                value.
              </td>
              <td>O(log n)</td>
            </tr>
            <tr>
              <td><code>void</code></td>
              <td>
                <code>update(int index, Function&lt;T, T&gt; updater)</code>
              </td>
              <td>
                Applies a transformation to a single element at the given index.
              </td>
              <td>O(log n)</td>
            </tr>
            <tr>
              <td><code>void</code></td>
              <td>
                <code>update(int l, int r, Function&lt;T, T&gt; func)</code>
              </td>
              <td>
                Applies a transformation function lazily to the range [l, r].
              </td>
              <td>O(log n)</td>
            </tr>
            <tr>
              <td><code>int</code></td>
              <td><code>size()</code></td>
              <td>Returns the size of the original input array.</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td><code>void</code></td>
              <td><code>printTree()</code></td>
              <td>Debugs the internal segment tree structure.</td>
              <td>O(n)</td>
            </tr>
          </tbody>
        </table>
      </section>

      <section class="doc-section">
        <h2>Implementation Details</h2>
        <p>
          <code>GenericLazySegmentTree&lt;T&gt;</code> is a generic,
          <strong>lazy propagation–based segment tree</strong> optimized for
          efficient range queries and range updates. It supports
          transformation-based updates using
          <code>Function&lt;T, T&gt;</code> and customizable associative merge
          operations via <code>BinaryOperator&lt;T&gt;</code>.
        </p>

        <p><strong>Core Data Structures:</strong></p>
        <ul>
          <li>
            <strong>Tree Array</strong> – <code>T[] tree</code> stores the
            segment values using a binary heap layout of size
            <code>≈ 2 × 2<sup>⌈log₂n⌉</sup> - 1</code>
          </li>
          <li>
            <strong>Lazy Array</strong> –
            <code>Function&lt;T, T&gt;[] lazy</code> stores deferred
            transformation functions for each segment node
          </li>
          <li>
            <strong>Original Input</strong> – <code>T[] input</code> holds a
            defensive copy of the user-provided array to ensure data integrity
          </li>
          <li>
            <strong>Combiner Function</strong> –
            <code>BinaryOperator&lt;T&gt; combine</code> defines how values are
            merged (e.g., <code>sum</code>, <code>min</code>, <code>max</code>)
          </li>
          <li>
            <strong>Identity Value</strong> –
            <code>T defaultValue</code> represents the neutral value for the
            merge function (e.g., 0 for sum, ∞ for min)
          </li>
        </ul>

        <p><strong>Build Strategy:</strong></p>
        <ul>
          <li>
            <strong>Recursive Construction</strong> – Builds the segment tree in
            <code>O(n)</code> by recursively combining child segments using
            <code>combine()</code>
          </li>
          <li>
            <strong>Balanced Layout</strong> – Internally uses binary heap
            indices with left and right children at
            <code>2 * node + 1</code> and <code>2 * node + 2</code>
          </li>
          <li>
            <strong>Safe Initialization</strong> – All tree and lazy entries are
            filled with <code>defaultValue</code> and
            <code>null</code> respectively
          </li>
        </ul>

        <p><strong>Lazy Propagation Mechanics:</strong></p>
        <ul>
          <li>
            <strong>Deferred Execution</strong> – Range updates store
            transformation functions in the lazy array instead of modifying the
            tree immediately
          </li>
          <li>
            <strong>Function Chaining</strong> – Multiple updates are composed
            using <code>Function::andThen</code> to preserve correct application
            order
          </li>
          <li>
            <strong>On-Demand Resolution</strong> – Tree nodes apply pending
            transformations only when accessed via update or query
          </li>
        </ul>

        <p><strong>Update Strategies:</strong></p>
        <ul>
          <li>
            <strong>Point Update (Value)</strong> – Directly replaces value at
            index and rebuilds affected path in <code>O(log n)</code>
          </li>
          <li>
            <strong>Point Update (Function)</strong> – Reads current value,
            applies transformer, and updates with result
          </li>
          <li>
            <strong>Range Update</strong> – Lazily applies a function to all
            elements in <code>[l, r]</code> by updating only relevant segments
            with deferred transforms
          </li>
        </ul>

        <p><strong>Query Evaluation:</strong></p>
        <ul>
          <li>
            <strong>Lazy Resolution</strong> – All pending updates are applied
            before accessing values during <code>query()</code>
          </li>
          <li>
            <strong>Partial Overlap Support</strong> – Combines left/right
            results recursively, skipping irrelevant segments
          </li>
          <li>
            <strong>Identity Handling</strong> – Out-of-range queries return
            <code>defaultValue</code>
            to ensure correctness of merges
          </li>
        </ul>

        <p><strong>Memory & Type Safety:</strong></p>
        <ul>
          <li>
            <strong>Unchecked Generic Array Creation</strong> – Uses type-safe
            unchecked cast for arrays of <code>T</code> and
            <code>Function&lt;T, T&gt;</code>
          </li>
          <li>
            <strong>Immutable Input Copy</strong> – Ensures user input is never
            mutated by internal tree logic
          </li>
          <li>
            <strong>Debug Support</strong> – Includes
            <code>printTree()</code> method to visualize internal tree state
          </li>
        </ul>
      </section>

      <!-- Detailed Usage Examples -->
      <section class="doc-section">
        <h2>Detailed Usage Examples</h2>

        <h3>Construction</h3>
        <pre class="code-block"><code>
GenericLazySegmentTree&lt;Integer&gt; st = new GenericLazySegmentTree&lt;&gt;(
    List.of(1, 3, 5, 7, 9),
    Integer::sum,
    0
);
        </code></pre>

        <h3><code>query(int l, int r)</code></h3>
        <p>
          Returns the sum of values from index <code>l</code> to <code>r</code>.
        </p>
        <pre class="code-block"><code>
int total = st.query(1, 3); // returns 3 + 5 + 7 = 15
        </code></pre>

        <h3><code>update(int index, T value)</code></h3>
        <p>Updates the element at the given index with a new value.</p>
        <pre class="code-block"><code>
st.update(2, 10); // replaces value at index 2 (was 5) with 10
        </code></pre>

        <h3><code>update(int index, Function&lt;T, T&gt; updater)</code></h3>
        <p>Applies a transformation to a single index.</p>
        <pre class="code-block"><code>
st.update(0, val -> val * 2); // multiplies value at index 0 by 2
        </code></pre>

        <h3><code>update(int l, int r, Function&lt;T, T&gt; func)</code></h3>
        <p>Applies a transformation function lazily to a range.</p>
        <pre class="code-block"><code>
st.update(1, 3, val -> val + 1); // increments values from index 1 to 3
        </code></pre>

        <h3><code>size()</code></h3>
        <p>Returns the number of elements in the tree.</p>
        <pre class="code-block"><code>
int n = st.size(); // returns 5
        </code></pre>

        <h3><code>printTree()</code></h3>
        <p>Prints the internal segment tree structure.</p>
        <pre class="code-block"><code>
st.printTree(); // helpful for debugging
        </code></pre>
      </section>

      <!-- Implementation Notes -->
      <section class="doc-section">
        <h2>Implementation Notes</h2>
        <ul>
          <li>
            All transformation functions in lazy updates are
            <strong>chained</strong> using <code>andThen</code> composition.
          </li>
          <li>
            Internal storage size is 4×n to handle segment tree depth
            efficiently.
          </li>
          <li>
            All methods are bounds-checked and will throw appropriate exceptions
            for invalid inputs.
          </li>
          <li>Supports both array-based and list-based constructors.</li>
        </ul>
      </section>

      <!-- Quick Example -->
      <section class="doc-section">
        <h2>Quick Example</h2>
        <pre class="code-block"><code>
GenericLazySegmentTree&lt;Integer&gt; tree = new GenericLazySegmentTree&lt;&gt;(
    List.of(2, 4, 6, 8),
    Integer::sum,
    0
);

tree.update(0, 10);                // set index 0 to 10
tree.update(1, val -> val + 5);    // add 5 to index 1
tree.update(2, 3, val -> val * 2); // multiply indices 2 and 3 by 2

System.out.println(tree.query(0, 3)); // output depends on above operations
tree.printTree();                    // debug internal nodes
        </code></pre>
      </section>
    </div>
    <footer>© 2025 Java Generic DSA Utils | Manoj Kumar G</footer>
    <script src="../../../scripts/docs.js"></script>
  </body>
</html>
